# HTLC Offerer
The HTLC scripts are not easy on the eyes, so let's inch our way towards them, starting with pseudo script. Alice, the ***HTLC offerer***, has to create an output where:
1) **Bob** can spend the output if he has the **revocation key**. This protects Bob in the future if Alice attempts to publish this HTLC commitment transaction after they have agreed to move to a new channel state.
2) **Bob** can spend the output if he can prove he has the **preimage**.
3) **Alice** can spend (effectively, reclaim) the output if the HTLC expires. Remember, we proposed a block height at which the HTLC must be completed by.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/AliceNoTimeoutTx.png" alt="AliceNoTimeoutTx" width="80%" height="auto">
</p>

**This is very nuanced and hard to see, but there is actually a bit of a dilema here!** Alice's spending path must be delayed by ```to_self_delay``` blocks so that Bob always has time to spend the funds via the recovation path if Alice cheats in the future.

#### Question: Looking at the simplified transaction, can you spot why this commitment transaction structure would be a problem?
<details>
  <summary>
    Answer
</summary>

Since the HTLC needs to be timelocked with an **absolute timelock** set to some block height in the future, the refund path cannot be claimed until **after that block height has passed**. This is meant to give Bob a specific timeframe for which he can safely retrieve the preimage and claim the HTLC.

**However**, Alice must enforce a `to_self_delay` **relative timelock** on her ability to spend the output, which protects Bob (in the future) in case Alice tries to cheat by publishing an old commitment state. This means, in the worst case, if Alice tries to spend this output after the contract expires expires, **she will still have to wait another** `to_self_delay` **blocks before she can spend the output**. This effectively gives extra time to Bob to provide the preimage and spend this output to himself. Do you know how we can fix this?

</details>

## Addressing The Dilema
To fix this timelock dilema, we'll add a second transaction for Alice, known as the **HTLC Timeout Transaction**. This transaction will use the same script as our `to_local` output, however, it will feature the following key differences:
1) The transaction with have an `nLocktime` set to the payment expiration date, known as `cltv_expiry` in the protocol. This means that the transaction cannot be mined until the `cltv_expiry` block height has passed. Therefore, Alice cannot claim back her funds until the HTLC has expired.
2) The input for this transaction is the HTLC output on the commitment transaction.
3) The HTLC spending path requires signatures from both Alice and Bob to spend. **They will pre-sign the HTLC Timeout transaction ahead of time**, effectively both agreeing to the "expiry" terms of the contract. 

Together, these changes allow for Alice to enforce the HTLC timeout while **also** enforcing the `to_self_delay`. This is because Alice can publish the **Timeout Tx**, which effectively expires the HTLC, however, she cannot claim her funds until the CSV timelock is satisfied.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/htlc_keys.png" alt="htlc_keys" width="50%" height="auto">
</p>


<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/Alice2ndStageTx.png" alt="Alice2ndStageTx" width="60%" height="auto">
</p>


## Putting It All Together

Putting it all together, the HTLC output has the following spending conditions:

1) **Revocation Path**: If Bob has the revocation key (in case Alice cheats by broadcasting an old transaction), he can immediately claim the output.
2) **Preimage Path**: If Bob provides the preimage, he can immediately claim the output.
3) **Timeout Path**: If Bob doesn't provide the preimage, Alice can claim the output via the HTLC Timeout Transaction, **which is set up in advance with Bob's signature for the 2-of-2 multisig condition. This allows Alice to reclaim the funds after the `cltv_expiry`**. 

For the HTLC Timeout Transaction, we have the following spending paths:
- **Revocation Path**: Bob can claim the output immediately with the revocation key.
- **Delayed Path**: Alice can claim the output after the `to_self_delay`.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/HTLCOffererTx.png" alt="HTLCOffererTx" width="100%" height="auto">
</p>

We won't go over the entire script in detail, but the one thing we will draw attention to is the `OP_CHECKMULTISIG` spending path, which sends to the **HTLC Timeout** transaction. Take a moment to review this and confirm that you understand the following:
- To expire the HTLC, the HTLC offerer must publish the HTLC Timeout transaction. This transaction is spending from a 2-of-2 multisig path, which Alice and Bob agree to pre-sign when creating the HTLC.
- Since the transaction is created ahead of time and signed by both parties, Bob can rest assured that Alice is only able to expire the HTLC using the **HTLC Timeout** transaction, which Bob knows protects him from Alice cheating in the future.


## âš¡ï¸ Build An HTLC Offerer Commitment Transaction

Complete `build_htlc_commitment_transaction`.

```rust
pub fn build_htlc_commitment_transaction(
    funding_txin: TxIn,
    revocation_pubkey: &PublicKey,
    remote_htlc_pubkey: &PublicKey,
    local_htlc_pubkey: &PublicKey,
    to_local_delayed_pubkey: &PublicKey,
    remote_pubkey: &PublicKey,
    to_self_delay: i64,
    payment_hash160: &[u8; 20],
    htlc_amount: u64,
    local_amount: u64,
    remote_amount: u64,
) -> Transaction {

  // create htlc, to_local, and to_remote scripts

  // create htlc, to_local, and to_remote outputs
  //    note, we must call .to_p2wsh() on our P2WSH scripts
  //    to obtain the hash that goes in the output's scriptPubKey field

  // declare the version and locktime for the transaction

  // build transaction
  // -- remember, inputs and outputs must be passed in as vectors (vec![])


}
```


As we saw earilier, you can choose to use the following functions to help complete this exercise:
<details>
  <summary>to_local()</summary>

Our `to_local` function from an earlier exercise will be helpful here.

```rust
pub fn to_local(
    revocation_key: &PublicKey,
    to_local_delayed_pubkey: &PublicKey,
    to_self_delay: i64,
) -> ScriptBuf {
    Builder::new()
        .push_opcode(opcodes::OP_IF)
        .push_key(revocation_key)
        .push_opcode(opcodes::OP_ELSE)
        .push_int(to_self_delay)
        .push_opcode(opcodes::OP_CSV)
        .push_opcode(opcodes::OP_DROP)
        .push_key(to_local_delayed_pubkey)
        .push_opcode(opcodes::OP_ENDIF)
        .push_opcode(opcodes::OP_CHECKSIG)
        .into_script()
}
```

</details>

<details>
  <summary>build_output()</summary>

A `build_output` function is available to you that takes an `amount` and `output_script` as arguments and produces a `TxOut` object that can be passed into a transaction.

```rust
pub fn build_output(amount: u64, output_script: ScriptBuf) -> TxOut {

    TxOut {
        value: Amount::from_sat(amount),
        script_pubkey: output_script,
    }
}
```

Below is an example of how `build_output` could be used:

```rust
let output = build_output(500_000, output_script.to_p2wsh());
```

</details>

<details>
  <summary>build_transaction()</summary>

To create a transaction, you can use the following helper function:

```rust
pub fn build_transaction(version: Version, locktime: LockTime, tx_ins: Vec<TxIn>, tx_outs: Vec<TxOut>) -> Transaction {
    Transaction {
        version: version,
        lock_time: locktime,
        input: tx_ins,
        output: tx_outs,
    }
}
```
### When building the transaction, note the following:

### Tx Inputs / Outputs
`build_transaction` expects `tx_ins` and `tx_outs` to be a **vector** (think: list) of `TxIn` and `TxOut` objects, respectively. To wrap your inputs or output in a vector, you can use the following notation:

```rust
vec![output_a, output_b]
```

### Version & Locktime
When specifying the version and locktime, you can use the following notation that rust-bitcoin provides. We'll learn about other varieties shortly, but this will help us get started.
- `Version::TWO`: Version 2 is post-BIP-68, which introduced sequence number relative locktimes. 
- `LockTime::ZERO`: This signals that there is no timelock on this transaction.

```rust
let version = Version::TWO;
let locktime = LockTime::ZERO;
```

</details>

<details>
  <summary>build_htlc_offerer_witness_script()</summary>

You can obtain an **HTLC Offerer** output script by using the below function. Yes, you can relax knowing you will not be asked to build an HTLC offerer script yourself, though you are welcome to do so for "fun" if you would like!

Remember, you will need to call `.to_p2wsh()` when building your output. See `build_output` for more info!
```rust
let htlc_offerer_script = build_htlc_offerer_witness_script(
      revocation_pubkey,
      remote_htlc_pubkey,
      local_htlc_pubkey,
      payment_hash160,
  );
```

</details>


Additionally, the following two funcitons will be useful:

You can obtain a **P2WPKH** output script by using the below function.
```rust
let p2wpkh_output_script = p2wpkh_output_script(pubkey);
```

## ðŸ‘‰ Get Our HTLC Transaction

Once your `build_htlc_commitment_transaction` is passing the tests, go to a **Shell** in your Repl and type in the below command. Make sure to replace `<funding_tx_id>` with the TxID from our funding transaction!

```
cargo run -- htlc -t <funding_tx_id> 
```

You should know by now! Head over to `src/ch1_intro_htlcs/transactions.txt` and add the **Tx ID** and **Tx Hex** to the **HTLC Tx ID** and **HTLC Tx Hex** sections.


## âš¡ï¸ Build An HTLC Timeout Transaction

Let's bring this HTLC commitment full circle by building our HTLC Timeout transaction. To do this, complete the function `build_htlc_timeout_transaction`.

```rust
pub fn build_htlc_timeout_transaction(
    htlc_txin: TxIn,
    revocation_pubkey: &PublicKey,
    to_local_delayed_pubkey: &PublicKey,
    to_self_delay: i64,
    cltv_expiry: u32,
    htlc_amount: u64
) -> Transaction {
    // create htlc script 

    // create htlc outputs
    //    note, we must call .to_p2wsh() on our P2WSH scripts
    //    to obtain the hash that goes in the output's scriptPubKey field

    // declare the version and locktime for the transaction

    // build transaction
    // -- remember, inputs and outputs must be passed in as vectors (vec![])
}
```

This is very similar to the previous exercise. The notable difference here is that you will need to account for the absolute locktime on this transaction!

You can specify an absolute locktime using `LockTime::from_consensus(<block_height>)`. For example, if you wanted to put an absolute locktime on a transaction such that it couldn't be mined until block height 900,000, you would do the following.

```rust
let locktime = LockTime::from_consensus(900_000);
```

Try completing the function! Click "Run" when you're finished to see if the test passes!

## ðŸ‘‰ Get Our HTLC Timeout Transaction

Once your `build_htlc_timeout_transaction` is passing the tests, go to a **Shell** in your Repl and type in the below command. Make sure to replace `<htlc_tx_id>` with the TxID from our **HTLC Timeout Tx ID** transaction. **NOTE**: the timeout transaction spends from an output within the commitment transaction, so you must specify the commitment transaction's TX ID.

```
cargo run -- htlc-timeout -t <htlc_tx_id> 
```

Once again, head over to `src/ch1_intro_htlcs/transactions.txt` and add the **Tx ID** and **Tx Hex** to the **HTLC Timeout Tx ID** and **HTLC Timeout Tx Hex** sections.