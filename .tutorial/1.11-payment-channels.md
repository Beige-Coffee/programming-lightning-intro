# Locking Funds In Our Payment Channel

For a payment channel to operate in a trustless environment, we're going to need to ensure that the funds being transfered **off-chain** in the payment channel cannot be unilaterally moved **on-chain**. In other words, Alice should not be able to show up to Bob's bar, give him an off-chain transaction in exchange for a glass of wine, and then move the same UTXO referenced in the off-chain transaction - rendering Bob's transaction invalid.

To mitigate against this vulnerability, we can begin our payment channel by locking the channel funds in a **Pay-to-Witness-Script-Hash (P2WSH) 2-of-2 multisig output** where Alice and Bob both provide one public key. We'll call this transaction our **"Funding Transaction"**. To move the funds out of this UTXO (effectively, closing the channel), Alice and Bob will need to provide both of their signatures.

**Alice will initially provide the funds for this payment channel**, so she will provide the input to this **"Funding Transaction"**. You can think of this as Alice showing up to Bob's bar and opening a tab with a specific amount. It's worth noting that Lightning does allow for "duel-funded" channels, where both parties bring funds, but we'll keep things simple by focusing on single-funded channels.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/funding.png" alt="funding.png" width="100%" height="auto">
</p>

#### Question: You'll see in the above diagram that Funding Transaction UTXO is for 5,000,000 sats. Why is this amount important for our payment channel?
<details>
  <summary>Answer</summary>

The amount in this UTXO is going to be channel balance for this payment channel. Therefore, neither channel party will be able to send the other channel party **more than this amount** of sats.

There are ways to increase this amount while the channel is active, called "splicing", but that is more advanced and will be covered later in this course.

</details>

### Sending a Payment
To send a payment, Alice and Bob can simply create a new transaction that spends from the funding transaction. Each new transaction will have an output for Alice and Bob with their respective channel balances.

Returning to our prior example, imagine Alice sends Bob 1 million sats.

Alice then decides to send Bob another 1 million sats for another round of drinks (big spender!).

For each payment, Alice is creating a new transaction, moving sats from her output to Bob's output. Recall, since the funds are locked on-chain in a 2-of-2 multisig, both Alice and Bob will need to provide a new signature for each commitment transaction. If you notice some security flaws below, you'd be right! We'll be fixing them shortly.

***PRO TIP!***: Don't be afraid to zoom in. Some of these diagrams may be hard to read, but the diagram should render quite nicely if you zoom in.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/simple_payment1.png" alt="simple_payment" width="100%" height="auto">
</p>

#### Question: As of now, none of the "off-chain" transactions are paying fees. Let's fix that! Who should be responsible for paying the on-chain fees?

<details>
  <summary>Answer</summary>

For "legacy" (pre-anchor outputs and pre-V3 commitments) commitment transactions, which this workbook is focused on, **the party that opens the channel pays the on-chain fees**. In other words, **fees are deducted from the output paying the channel opener**. In this case, that's Alice.

If you've been following Lightning Network development, you're likely aware that many of the advancements in Lightning have been motivated by mitigating issues related to fees. We'll dig into this more a little later. We haven't yet introduced all of the nuances of how Lightning works, so we can't fully elaborate on this just yet.

In the meantime, let's update our channel between Alice and Bob. **We'll assume that 1,000 sats is a sufficient fee, so we'll deduct that amount from Alice's output**. Therefore, the sum of Alice + Bob's outputs is now 4,999,000 and the remaining 1,000 goes towards miner fees.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/simple_payment_fees.png" alt="simple_payment_fees" width="100%" height="auto">
</p>

</details>

## ‚ö°Ô∏è Build A Payment Channel Funding Transaction

Complete `build_funding_transaction` in `src/exercises/exercises.rs`. This function takes the following parameters:
- `txins`: A vector of transaction inputs (`Vec<TxIn>`).
- `alice_pubkey`: Alice's public key (`&PublicKey`), which will be included in the 2-of-2 multisig.
- `bob_pubkey`: Bob's public key (`&PublicKey`), which will be included in the 2-of-2 multisig.
- `amount`: The channel amount. This will be an unsigned 64-bit integer `u64` structure.

```rust
pub fn build_funding_transaction(
    txins: Vec<TxIn>,
    alice_pubkey: &PublicKey,
    bob_pubkey: &PublicKey,
    amount: Amount,
) -> Transaction {

  // Step 1: Build a Witness Script for the Multisig

  // Step 2: Create the Funding Transaction Output

  // Step 3: Define Version and Locktime

  // Step 4: Build and Return the Transaction
}
```

This transaction will return a `Transaction` structure, as defined by rust-bitcoin.

```rust
pub struct Transaction {
    pub version: Version,
    pub lock_time: LockTime,
    pub input: Vec<TxIn>,
    pub output: Vec<TxOut>,
}
```

<details>
  <summary>Step 1: Build a Witness Script for the Multisig</summary>

Use the `two_of_two_multisig_witness_script` function from the previous exercise to create a 2-of-2 multisig witness script.

**Note**, to declare a variable in rust, use the `let` keyword. Also, each statement in Rust, including variable declarations, must end with a semicolon (`;`).

```rust
let witness_script = two_of_two_multisig_witness_script(alice_pubkey, bob_pubkey);
```

</details>

<details>
  <summary>Step 2: Create the Funding Transaction Output</summary>

Create a `TxOut` object for the funding transaction using the `build_output` function, which takes the amount and a P2WSH script derived from the witness script.

```rust
let txout = build_output(amount, witness_script.to_p2wsh());
```
- Before passing your witness script to build_output, you must call `.to_p2wsh()` on it. This converts your witness script into a proper P2WSH output script with format `OP_0 <32-byte-script-hash>`. This is required because P2WSH outputs don't contain the full witness script - only its hash.
- `build_output` creates a `TxOut` with the specified amount and scriptPubKey.

<details>
  <summary>Click to learn more about build_output</summary>

`build_output` is a helper function available to you. It takes an `amount` and `output_script` as arguments and produces a `TxOut` object that can be passed into a transaction.

```rust
pub fn build_output(amount: u64, output_script: ScriptBuf) -> TxOut {

    TxOut {
        value: Amount::from_sat(amount),
        script_pubkey: output_script,
    }
}
```

Below is an example of how `build_output` could be used:

```rust
let output = build_output(500_000, output_script.to_p2wsh());
```

</details>

</details>

<details>
  <summary>Step 3: Define Version and Locktime</summary>

Set the transaction version to 2 and locktime to zero using the provided rust-bitcoin enums.

```rust
let version = Version::TWO;
let locktime = LockTime::ZERO;
```
- `Version::TWO` sets the transaction version to 2, which supports BIP-68 relative locktimes.
- `LockTime::ZERO` indicates no timelock on the transaction.

</details>

<details>
  <summary>Step 4: Build and Return the Transaction</summary>

Construct the `Transaction` object using the `build_transaction` helper function, with the defined version, locktime, inputs, and the output in a vector.

```rust
pub fn build_transaction(version: Version, locktime: LockTime, tx_ins: Vec<TxIn>, tx_outs: Vec<TxOut>) -> Transaction {
    Transaction {
        version: version,
        lock_time: locktime,
        input: tx_ins,
        output: tx_outs,
    }
}
```

Remember, `build_transaction` expects `tx_outs` to be a **vector** (think: list) of `TxOut` objects. To wrap your output in a vector, you can use the following notation:

```rust
vec![output]
```

Below is an example of what it would look like to use the `build_transaction` helper function.
```rust
let tx = build_transaction(
    version,
    locktime,
    txins,
    vec![txout],
);
```

</details>

## üëâ Get Our Funding Transaction
Now for the fun part! Once your `build_funding_transaction` is passing the tests, go to a **Shell** in your Repl and type in the below command.

```
cargo run -- funding
```

Under the hood, this command fetches a UTXO from our regtest wallet and creates a two-of-two multisig transaction using the function we just created. In case you're wondering which public keys are being used for "Alice" and "Bob", the background code in this Replit is creating new private-public key pairs for Aice and Bob. This will be helpful in the future, as we will need to generate signatures for the off-chain "payments".

Once you run it, you should see an output like this...

```
Tx ID:
8077cb7913e97caefb6199deeb1a14b4ecc740206f05cdfb56605da794ae0e8f

Tx Hex: 020000000001018d54238793c4547bb913e369a27c74bc08fc20c33197f5690f41565c7cfad12e0000000000ffffffff01784a4c0000000000220020657760ca015175e42ff5b4470563b23adcf0d2973a0506a176a5569690d64437024730440220548d3aeae38390d1d4f79b8756b5758d131051ddce223aa4f395bb88be1ccaeb02201698654ab9c29d41822771cd3a75bffec87488322a46783f64cd53aefb1f5d960121024e77786b0c8bef20ef469345cf4c306b14dee25dd5bab152155bee1e2115e93100000000
```

This is our funding transaction. **Note: we have NOT broadcasted this yet**. Go ahead and copy the **Tx Hex** and **Tx ID** and save them in the file `src/exercises/transactions.txt` under the headings **Funding Tx Hex** and **Funding Tx ID**. We'll wait to publish it!

Finally, go ahead and run the below command in your shell, replacing **raw tx hex** with the transaction hex we just generated.

```
decodetx <raw tx hex>
```

You should get an output like the below. See if you can map this output back to the diagram above. Most of these fields will not map directly, but the following are represented in the diagram:
- vin: txid
- vin: vout
- vin: scriptSig
- vin: txinwitness
- vout: value
- vout: scriptPubKey

```
{
  "txid": "b43eee65237aaba00e7d2a2b442635d0e973b03515413b4be14f669e7bf09f1f",
  "hash": "81b475238dbf1d0ecee44ec82cf21c803e0314336df32c1f684909943243c749",
  "version": 2,
  "size": 203,
  "vsize": 122,
  "weight": 485,
  "locktime": 0,
  "vin": [
    {
      "txid": "f5e9c01a663dd228485fdf07fb4ae95d46f3ee71ba93a0c2d77fa8998b57c44a",
      "vout": 1,
      "scriptSig": {
        "asm": "",
        "hex": ""
      },
      "txinwitness": [
        "30440220783ff032365771673328b10c7516622eb95337b80a9b781cccec6d7d61e39a2702205174d10e39e667cf32f4ad951f266e1070789010f22b9ad50eb70478164de92401",
        "02d865e012869cc63aafcbcd17561ec971a0ebefdf90d2be191708efe50652a641"
      ],
      "sequence": 4294967295
    }
  ],
  "vout": [
    {
      "value": 0.05000000,
      "n": 0,
      "scriptPubKey": {
        "asm": "0 657760ca015175e42ff5b4470563b23adcf0d2973a0506a176a5569690d64437",
        "desc": "addr(bcrt1qv4mkpjsp2967gtl4k3rs2caj8tw0p55h8gzsdgtk54tfdyxkgsmsvc0c37)#xfhwt3ez",
        "hex": "0020657760ca015175e42ff5b4470563b23adcf0d2973a0506a176a5569690d64437",
        "address": "bcrt1qv4mkpjsp2967gtl4k3rs2caj8tw0p55h8gzsdgtk54tfdyxkgsmsvc0c37",
        "type": "witness_v0_scripthash"
      }
    }
  ]
}
```

## Problem: Potential Loss of Funds

Take another look at the funding transaction output below. How can Alice lose all of her funds in this setup?

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/funding.png" alt="funding.png" width="100%" height="auto">
</p>

<details>
  <summary>Answer</summary>

If Bob stops responding or refuses to cooperate, then there's no way for Alice to retrieve her funds from this payment channel. This is because, to spend from a 2-of-2 multisig, you need signatures from *both* parties.
</details>


How can we address this problem for Alice?

<details>
  <summary>Answer</summary>

There are a few different ways to go about this, but the general solution is that we will need to create a way for Alice to recieve a "refund" or unilateral exit from the channel. Can you think of how we can implement this?
</details>