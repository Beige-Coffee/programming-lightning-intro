# Channel Keys Deep Dive 

Great, at this point, we've implemented our `NodeKeysManager`, which has the following cryptographic key material ready for us to use:
- **Node Secret**:  Private Key, derived from hardened child at index `0`.
- **Node ID**:  Public Key, derived from Node Secret.
- **Shutdown Public Key**:  Public Key, derived from  derived from hardened child at index `1`.
- **Channel Master Key**: Extended Private Key, derived from hardened child at index `2`. As we'll soon see, we can use this extended private key to create a child private key for each channel our Lightning node opens.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/wallet_paths_ex.png" alt="wallet_paths_ex" width="90%" height="auto">
</p>

Now we're ready to derive **channel-specific** cryptographic material. As a reminder, we need to derive the following:
  - **Revocation Basepoint + Secret**: Basepoint/Secret used to derive revocation keys.
  - **Payment Basepoint + Secret**: Basepoint/Secret used to derive keys for our balance in counterparty's commitment transactions (ex: their `to_remote`).
  - **Delayed Payment Basepoint + Secret**: Basepoint/Secret used to derive keys for delayed paths (ex: `to_local`).
  - **HTLC Basepoint + Secret**: Basepoint/Secret used to derive keys in commitment transaction HTLC outputs.
  - **Commitment Seed**: The commitment seed is a 256-bit scalar used to generate a series of secrets **for each commitment state**. These secrets will combined with the above basepoints/secrets to generate the private and public keys used in each commitment transactions output scripts.

As you look at the below diagram, keep in mind that it is not meant to be an *exact* representation of how to derive the keys - that's what the coding exercises are for! Instead, it's meant to convey high-level concepts, such as the fact that we will be taking the SHA256 of certain pieces of information - like the serialized channel master key (derivation path `m/2'`) and a unique channel id - and using that as **secure entropy** to create keys that are specific to this Lightning channel.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/channel_keys.png" alt="channel_keys" width="100%" height="auto">
</p>

## ⚡️ Implement `derive_channel_keys` for our NodeKeysManager
For this exercise, we'll implement the `derive_channel_keys` for our `NodeKeysManager`. This function will take a unique 32-byte array as an input, which we we will use as a **unique ID** for each channel that our `NodeKeysManager` produces keys for.

Once complete, it will return a `ChannelKeysManager` of the following structure. As you can see, this stores each of the **basepoint secrets** that we will need to create the keys for our Lightning channel. Remember, these secrets are also private keys themselves, but we call them "basepoint secrets" because they are not used as private keys but, instead, as cryptographic tools to create private/public keys. We'll see how in the next section.

```rust
pub struct ChannelKeysManager {
    pub commitment_seed: [u8; 32],
    pub revocation_base_key: SecretKey,
    pub payment_key: SecretKey,
    pub delayed_payment_base_key: SecretKey,
    pub htlc_base_key: SecretKey,
}
```

### Approach Via Entropy
A useful way to approach conceptualizing (and completing) this exercise is from the perspective of **entropy**.

Entropy, a measure of randomness or unpredictability, is at the heart of cryptographic security. Why? Because entropy ensures that the keys we generate are both unique and secure. They are *our* keys, and attackers should not be able to guess or otherwise reconstruct the keys.

When it comes to Lightning, we want to ensure that all of the keys we generate for each channel we create are unique. For example, take a look at the diagram below. All of the keys (and cryptographic material, such as the commitment seed) must be unique to each channel.
<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/channel_entropy.png" alt="channel_entropy" width="100%" height="auto">
</p>

To complete this exercise, we'll need to accomplish the following steps:
1. Define a source of entropy that we can use to generate **channel-level basepoints** and our **commitment seed**.
2. Derive our **commitment seed**, using the entropy we defined above.
3. Derive each unique **channel-level basepoint**, using the entropy we defined above.
4. Build & Return `ChannelKeysManager`.

Together, these steps will enable us to create unique and secure basepoints for every payment channel our Lightning node creates. 

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/channel_keys_entropy.png" alt="channel_keys_entropy" width="60%" height="auto">
</p>


```rust
impl NodeKeysManager {
    pub fn derive_channel_keys(&self, channel_id_params: &[u8; 32]) -> SimpleChannelKeys {

        // exctract 
        let chan_id = u64::from_be_bytes(channel_id_params[0..8].try_into().unwrap());
        
        let mut unique_start = Sha256::engine();
        unique_start.input(channel_id_params);
        unique_start.input(&self.seed);

        // We only seriously intend to rely on the channel_master_key for true secure
        // entropy, everything else just ensures uniqueness. We rely on the unique_start (ie
        // starting_time provided in the constructor) to be unique.
        let child_privkey = self
            .channel_master_key
            .derive_priv(
                &self.secp_ctx,
                &ChildNumber::from_hardened_idx((chan_id as u32) % (1 << 31))
                    .expect("key space exhausted"),
            )
            .expect("Your RNG is busted");
        unique_start.input(&child_privkey.private_key[..]);

        let seed = Sha256::from_engine(unique_start).to_byte_array();

        let commitment_seed = {
            let mut sha = Sha256::engine();
            sha.input(&self.seed);
            sha.input(&b"commitment seed"[..]);
            Sha256::from_engine(sha).to_byte_array()
        };

        let revocation_base_key = key_step_derivation(&seed, &b"revocation base key"[..], &commitment_seed[..]);
        let payment_key = key_step_derivation(&seed, &b"payment key"[..], &revocation_base_key[..]);
        let delayed_payment_base_key = key_step_derivation(&seed, &b"delayed payment key"[..], &payment_key[..]);
        let htlc_base_key = key_step_derivation(&seed, &b"HTLC base key"[..], &delayed_payment_base_key[..]);

        SimpleChannelKeys {
            commitment_seed,
            revocation_base_key,
            payment_key,
            delayed_payment_base_key,
            htlc_base_key,
        }
    }
}
```
Below, you’ll find step-by-step guidance to assist in completing the `derive_channel_keys` function.

<details>
<summary>Step 1: Generate Unique Entropy For This Channel</summary>

First, we'll start by creating a seed, which can be used to provide entropy and ensure all keys that we generate for this channel are unique. We'll do this by hashing the `channel_id`, which is provided as an input, along with our node’s BIP32 seed, and the serialized private key of a derived child from our `channel_master_key` (deivation path `m/2'`.

Remember, when creating a seed, our goal is to ensure it has secure entropy and is unqiue for each channel. With this in mind, can note that the serialized child private key from our `channel_master_key` provides sufficient entropy. The `channel_id` helps ensure uniqueness.

```rust
let mut unique = Sha256::engine();
    unique.input(&channel_id.to_be_bytes());
    unique.input(&self.seed);

let child_privkey = self
    .channel_master_key
    .derive_priv(
        &self.secp_ctx,
        &ChildNumber::from_hardened_idx(channel_id)
            .expect("key space exhausted"),
    )
    .expect("Your RNG is busted");
    
    unique.input(&child_privkey.private_key[..]);
let seed = Sha256::from_engine(unique).to_byte_array();
```
- `Sha256::engine()` initializes a SHA-256 hash engine.
- `.input(&channel_id.to_be_bytes())` and `.input(&self.seed)` add the channel ID and node’s seed to the hash.
- `self.channel_master_key.derive_priv` derives a child private key at a hardened index based on `channel_id`:
  - `.expect("key space exhausted")` assumes a valid index (handle errors in production).
  - `.expect("Your RNG is busted")` assumes derivation succeeds.
- `.input(&child_privkey.private_key[..])` adds the child private key to the hash.
- `Sha256::from_engine(unique).to_byte_array()` finalizes the hash, producing a 32-byte `channel_seed`.

</details>

<details>
<summary>Step 2: Derive Commitment Seed</summary>

Generate a commitment seed by hashing the `channel_seed` with a fixed string to ensure key-specific entropy.

```rust
let commitment_seed = {
    let mut sha = Sha256::engine();
    sha.input(&channel_seed);
    sha.input(&b"commitment seed"[..]);
    Sha256::from_engine(sha).to_byte_array()
};
```
- `Sha256::engine()` initializes a new SHA-256 hash engine.
- `.input(&channel_seed)` adds the channel's seed for entropy.
- `.input(&b"commitment seed"[..])` adds a fixed string to differentiate the commitment seed from other keys.
- `Sha256::from_engine(sha).to_byte_array()` produces a 32-byte `commitment_seed`, which is used to ensure each commitment transaction has unique public/private keys.

</details>

<details>
<summary>Step 3: Derive Basepoint Keys</summary>

Derive the revocation, payment, delayed payment, and HTLC basepoint keys using `key_step_derivation`, a helper function that computes a new seed from the provided inputs and returning a unique private key based on the inputs.

```rust
let revocation_base_key = key_step_derivation(&channel_seed, &b"revocation base key"[..], &commitment_seed[..]);

let payment_key = key_step_derivation(&channel_seed, &b"payment key"[..], &revocation_base_key[..]);

let delayed_payment_base_key = key_step_derivation(&channel_seed, &b"delayed payment key"[..], &payment_key[..]);

let htlc_base_key = key_step_derivation(&channel_seed, &b"HTLC base key"[..], &delayed_payment_base_key[..]);
```
- `key_step_derivation` generates a `SecretKey` by hashing the provided `seed`, a label (e.g., `b"revocation base key"`), and a prior key or seed (e.g., `commitment_seed`).
- Each key is derived sequentially, using the previous key as input to ensure a chain of entropy:
  - `revocation_base_key` for revocation keys.
  - `payment_key` for non-delayed payment spending paths.
  - `delayed_payment_base_key` for delayed payment spending paths.
  - `htlc_base_key` for HTLC outputs.

</details>

<details>
<summary>Step 4: Return ChannelKeysManager</summary>

Finally, once we've derived all of our seeds and secrets, we can return a `ChannelKeysManager`, which will hold all of this cryptgraphic material.

Now, we just need to implement a few functions that will use this material to generate the public and private keys we need for each commitment state!

```rust
ChannelKeysManager {
    commitment_seed,
    revocation_base_key,
    payment_key,
    delayed_payment_base_key,
    htlc_base_key,
}
```

</details>