# Channel Keys Deep Dive 

Great, at this point, we've implemented our `NodeKeysManager`, which has the following cryptographic key material ready for us to use:
- **Node Secret**:  Private Key, derived from hardened child at index `0`.
- **Node ID**:  Public Key, derived from Node Secret.
- **Shutdown Public Key**:  Public Key, derived from  derived from hardened child at index `1`.
- **Channel Master Key**: Extended Private Key, derived from hardened child at index `2`. As we'll soon see, we can use this extended private key to create a child private key for each channel our Lightning node opens.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/wallet_paths_ex.png" alt="wallet_paths_ex" width="90%" height="auto">
</p>

Now we're ready to derive **channel-specific** cryptographic material. As a reminder, we need to derive the following:
  - **Revocation Basepoint + Secret**: Basepoint/Secret used to derive revocation keys.
  - **Payment Basepoint + Secret**: Basepoint/Secret used for our balance in counterparty's commitment transactions (ex: their `to_remote`).
  - **Delayed Payment Basepoint + Secret**: Basepoint/Secret used to derive keys for delayed paths (ex: `to_local`).
  - **HTLC Basepoint + Secret**: Basepoint/Secret used to derive keys in commitment transaction HTLC outputs.
  - **Commitment Seed**: The commitment seed is a 256-bit scalar used to generate a series of secrets **for each commitment state**. These secrets will be combined with the above basepoints/secrets to generate the private and public keys used in each commitment transactions output scripts.

As you look at the below diagram, keep in mind that it is not meant to be an *exact* representation of how to derive the keys - that's what the coding exercises are for! Instead, it's meant to convey high-level concepts, such as the fact that we will be taking the SHA256 of certain pieces of information - like the serialized channel master key (derivation path `m/2'`) and a unique channel id - and using that as **secure entropy** to create keys that are specific to this Lightning channel.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/channel_keys.png" alt="channel_keys" width="100%" height="auto">
</p>

## ⚡️ Implement `derive_channel_keys` for our NodeKeysManager
For this exercise, we'll implement the `derive_channel_keys` for our `NodeKeysManager`. This function will take a unique 32-byte array as an input, which we we will use as a **unique ID** for each channel that our `NodeKeysManager` produces keys for.

Once complete, it will return a `ChannelKeysManager` of the following structure. As you can see, this stores each of the **basepoint secrets** that we will need to create the keys for our Lightning channel. Remember, these secrets are also private keys themselves, but we call them "basepoint secrets" because they are not used as private keys but, instead, as cryptographic tools to create private/public keys. We'll see how in the next section.

```rust
pub struct ChannelKeysManager {
    pub commitment_seed: [u8; 32],
    pub revocation_base_key: SecretKey,
    pub payment_key: SecretKey,
    pub delayed_payment_base_key: SecretKey,
    pub htlc_base_key: SecretKey,
}
```

### Approach Via Entropy
A useful way to approach conceptualizing (and completing) this exercise is from the perspective of **entropy**.

Entropy, a measure of randomness or unpredictability, is at the heart of cryptographic security. Why? Because entropy ensures that the keys we generate are both unique and secure. They are *our* keys, and attackers should not be able to guess or otherwise reconstruct the keys.

When it comes to Lightning, we want to ensure that all of the keys we generate are unique. For example, take a look at the diagram below. All of the keys (and cryptographic material, such as the commitment seed) must be unique to each channel.
<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/channel_entropy.png" alt="channel_entropy" width="100%" height="auto">
</p>

To complete this exercise, we'll need to accomplish the following steps:
1. Define a source of entropy that we can use to generate **channel-level basepoints** and our **commitment seed**.
2. Derive our **commitment seed**.
3. Derive each unique **channel-level basepoint**.
4. Build & Return `ChannelKeysManager`.

To accomplish this, we're going to take advantage of:
- **SHA Chaining**: This is a lightweight and simple method to derive keys sequentially and deterministically by propagating entropy throughout the key derivation process. As we'll see in the coding exercise, we will iteratively include the prior key in the current hash function when deriving the new key.
- **Human-Readable Domain Separation**: We'll append labels, such as "commitment seed", to our SHA hash function, adding context to indicate the purpose of each key and helping to prevent collisions.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/channel_keys_entropy.png" alt="channel_keys_entropy" width="60%" height="auto">
</p>


```rust
impl NodeKeysManager {
    pub fn derive_channel_keys(&self, channel_id_params: &[u8; 32]) -> SimpleChannelKeys {

        // Step 1: Generate Unique Entropy For This Channel

        // Step 2: Derive Commitment Seed

        // Step 3: Derive Basepoint Keys

        // Step 4: Return ChannelKeysManager

        SimpleChannelKeys {
            commitment_seed,
            revocation_base_key,
            payment_key,
            delayed_payment_base_key,
            htlc_base_key,
        }
    }
}
```
Below, you’ll find step-by-step guidance to assist in completing the `derive_channel_keys` function.

<details>
<summary>Step 1: Generate Unique Entropy For This Channel</summary>

First, we'll start by creating a seed of entropy for our channel, which will ensure that all of the keys we generate for this channel are unique. We'll do this by hashing the `channel_id`, which is provided as an input, along with our node’s BIP32 seed, and the serialized private key of a derived child from our `channel_master_key` (deivation path `m/2'`.

Remember, when creating a seed, our goal is to ensure it has secure entropy and is unqiue for each channel. With this in mind, we can note that the serialized child private key from our `channel_master_key` provides sufficient entropy. 

```rust
let mut unique = Sha256::engine();
    unique.input(&channel_id.to_be_bytes());
    unique.input(&self.seed);

let child_privkey = self
    .channel_master_key
    .derive_priv(
        &self.secp_ctx,
        &ChildNumber::from_hardened_idx(channel_id)
            .expect("key space exhausted"),
    )
    .expect("Your RNG is busted");
    
    unique.input(&child_privkey.private_key[..]);
    
let channel_seed = Sha256::from_engine(unique).to_byte_array();
```
- `Sha256::engine()` initializes a SHA-256 hash engine.
- `.input(&channel_id.to_be_bytes())` and `.input(&self.seed)` add the channel ID and node’s seed to the hash.
- `self.channel_master_key.derive_priv` derives a child private key at a hardened index based on `channel_id`:
  - `.expect("key space exhausted")` assumes a valid index (handle errors in production).
  - `.expect("Your RNG is busted")` assumes derivation succeeds.
- `.input(&child_privkey.private_key[..])` adds the child private key to the hash.
- `Sha256::from_engine(unique).to_byte_array()` finalizes the hash, producing a 32-byte `channel_seed`.

</details>

<details>
<summary>Step 2: Derive Commitment Seed</summary>

Generate a commitment seed by hashing the `channel_seed` with a fixed string to ensure key-specific entropy.

```rust
let commitment_seed = {
    let mut sha = Sha256::engine();
    sha.input(&channel_seed);
    sha.input(&b"commitment seed"[..]);
    Sha256::from_engine(sha).to_byte_array()
};
```
- `Sha256::engine()` initializes a new SHA-256 hash engine.
- `.input(&channel_seed)` adds the channel's seed for entropy.
- `.input(&b"commitment seed"[..])` adds a fixed string to differentiate the commitment seed from other keys.
- `Sha256::from_engine(sha).to_byte_array()` produces a 32-byte `commitment_seed`, which is used to ensure each commitment transaction has unique public/private keys.

</details>

<details>
<summary>Step 3: Derive Basepoint Keys</summary>

Derive the revocation, payment, delayed payment, and HTLC basepoint keys using `key_step_derivation`, a helper function that computes a new seed from the provided inputs, returning a unique private key. Remember, we need to add a context label for each key!

```rust
let revocation_base_key = key_step_derivation(&channel_seed, &b"revocation base key"[..], &commitment_seed[..]);

let payment_key = key_step_derivation(&channel_seed, &b"payment key"[..], &revocation_base_key[..]);

let delayed_payment_base_key = key_step_derivation(&channel_seed, &b"delayed payment key"[..], &payment_key[..]);

let htlc_base_key = key_step_derivation(&channel_seed, &b"HTLC base key"[..], &delayed_payment_base_key[..]);
```
- `key_step_derivation` generates a `SecretKey` by hashing the provided `seed`, a label (e.g., `b"revocation base key"`), and a prior key or seed (e.g., `commitment_seed`).
- Each key is derived sequentially, using the previous key as input to ensure a chain of entropy.

<details>
<summary>Click here to see how `key_step_derivation` is defined</summary>

```rust
fn key_step_derivation(seed: &[u8; 32], bytes: &[u8], previous_key: &[u8]) -> SecretKey {
    let mut sha = Sha256::engine();
    sha.input(seed);
    sha.input(&previous_key[..]);
    sha.input(&bytes[..]);
    SecretKey::from_slice(&Sha256::from_engine(sha).to_byte_array())
        .expect("SHA-256 is busted")
}
```

</details>

</details>

<details>
<summary>Step 4: Return ChannelKeysManager</summary>

Finally, once we've derived all of our seeds and secrets, we can return a `ChannelKeysManager`, which will hold all of this cryptgraphic material.

Now, we just need to implement a few functions that will use this material to generate the public and private keys we need for each commitment state!

```rust
ChannelKeysManager {
    commitment_seed,
    revocation_base_key,
    payment_key,
    delayed_payment_base_key,
    htlc_base_key,
}
```

</details>