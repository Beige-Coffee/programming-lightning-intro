# Enhancing Our Payment Channel Refund

So far, we've learned of one construction for implementing a "refund" for our payment channel. It works, but it's not ideal, as the channel is time-bound. To address this concern, let’s remove the timelock so that our channel doesn't have an arbitrary end date.

## Create A New "Refund" Transaction That Spends From The Funding Transaction

#### ✅ NOTE: This new payment channel construction is actually how Lightning channels work, so we're back on the path to building our own modern channel from the ground up!

Another approach to ensuring Alice can retrieve her Bitcoin if Bob stops cooporating is to create a new transaction that spends from the funding transaction. This transaction will act as a "refund" transaction, as it will pay each channel member the amount of sats that they currently have at the time of opening the channel. 

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/AliceBobRefund.png" alt="AliceBobRefund" width="100%" height="auto">
</p>

#### Question: Is it safe to create the "refund" transaction *after* broadcasting the funding transaction?
<details>
  <summary>Answer</summary>

**NO!**

It's vital to note that the refund transaction still needs *both* Alice and Bob's signatures to spend. Therefore, creating the refund transaction should be thought of as a critical step that needs to be completed ***before*** publishing the funding transaction. Otherwise, if Alice broadcasts the funding transaction before they have both signed the refund transaction, Bob could refuse to sign the refund transaction, effectively holding Alice's funds hostage.

</details>

</details>

#### Question: For the first channel state, Bob doesn't have any funds on his side of the channel. What should we do with his output?
<details>
  <summary>Answer</summary>

If we tried creating a transaction with 0 sats for Bob, that would be considered non-standard and would not be relayed. Even if it was possible, it would take up extra space and make our transaction size larger, adding unnecessary fees. Since Bob has no funds on his side of the channel, we have the following two options:

1) **We can create a refund transaction with no output for Bob.**

The first option is to ***not*** include an output for Bob. This is often how Lightning payment channels begin in the "real world", as, usually, all of the funds are on one side of the channel when it's opened.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/AliceRefundV2.png" alt="AliceRefundV2" width="100%" height="auto">
</p>

2) **We can "push" some sats to Bob's side of the channel at the start.**

This is done by specifying an amount (in milli satoshis) in the `push_msat` field of the `open_channel` [message](https://github.com/t-bast/bolts/blob/zero-fee-commitments/02-peer-protocol.md#the-open_channel-message). This can be seen as an initial payment that is sent to Bob at channel start.

The visuals for the rest of this workshop will be a little smoother if Bob has an output to start, so we'll give him 500 sats because we're nice people. Fun fact, we're choosing 500 sats because it's above the [dust limit](https://github.com/t-bast/bolts/blob/zero-fee-commitments/03-transactions.md#dust-limits) of 294 sats for P2WPKH outputs. If it were below this, we would not generate an output for Bob.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/AliceRefundV3.png" alt="AliceRefundV3" width="100%" height="auto">
</p>

</details>

#### Question: Does the output order matter for the refund transaction?
<details>
  <summary>Answer</summary>

In the context of Lightning, yes!

Remember how we ordered our public keys in the 2-of-2 funding transaction such that the public key that was lexicographically lesser was first? The reasoning for ordering outputs is similar. By standardizing these sorts of details, we reduce ambiguity and make it easier for channel party's in Lightning to generate signatures for each other.

For a more technical answer, note that all signatures generated for commitment transactions in the Lightning network will use the `SIGHASH_ALL` flag, indicating that the signature covers all of the inputs and outputs in the transaction. Therefore, if the order of the outputs were to change, it would result in a different signature!

The Lightning network spec (specifically, BOLT 3: [Transaction Output Ordering](https://github.com/lightning/bolts/blob/master/03-transactions.md#transaction-output-ordering)) specifies that outputs should be ordered in the following manner:
- First, according to their value - smallest first.
  - If there is a tie, the output with the lexicographically lesser `scriptpubkey` comes first, then selecting the shorter script (if they differ in length).
  - For HTLC outputs, if there is a tie after sorting via the above, then they are ordered in increasing `cltv_expiry` order.

If some of these words don't make sense, don't worry! We'll cover them later.


#### Now that we know how to order our outputs, below is a visual representation of what our new transaction will look like.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/refund_ordered.png" alt="refund_ordered" width="50%" height="auto">
</p>

</details>


## Locking to Each Channel Party's Public Key
Great! We've identified a way to issue a refund transaction that isn't time-bound. All we have to do is lock bitcoin to each channel party's **public key**. As we learned earlier, this can be achieved by creating a **Pay-To-Witness-Public-Key-Hash** (**P2WPKH**) output. 

To help us build the refund transaction, we'll introduce a new public key, called a **commitment public key**. This key actually has a different name per the Lightning protocol specs, but we're not revealing that name yet for educational purposes! 

Also, note that the **commitment public key** has a `1` appended to the end of it. Of course, we don't literally append a `1` to public keys when building payment channels. Instead, this is meant to signify that this public key is specific to this payment (commitment transaction). More specifically, each new commitment transaction will have its own *unique* **commitment public key**, and they will be derived deterministically from the same secret key material. This ensures that you do not need to store every public key for each commitment transaction, as you will be able to recreate them from the base key. Per [BOLT 3 "Key Derivation"](https://github.com/t-bast/bolts/blob/zero-fee-commitments/03-transactions.md#key-derivation), the main reason for changing the public keys for each commitment is so that the Transaction ID changes for each commitment. This is required enable watchtowers to trustlessly monitor the blockchain for you, but these exact details are outside of the scope of this section of the workshop. 

This main portion of this workshop will not dive deep into how public and private keys are derived in a Lightning wallet. However, if you're interested in learning (and building!) your own Lightning key derivation functionality, there is an in-depth tutorial in the **Apendex** section.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/AliceAndBob2.png" alt="SampleTx" width="50%" height="auto">
</p>

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/AliceBobRefundP2WPKH.png" alt="AliceBobRefundP2WPKH" width="100%" height="auto">
</p>

## ⚡️ Build A Payment Channel Refund Transaction

Complete `build_refund_transaction`. This function takes the following parameters:
- `funding_txin`: Funding transaction input (`TxIn`).
- `alice_pubkey`: Alice's public key (`&PublicKey`), which will used to build Alice's output.
- `bob_pubkey`: Bob's public key (`&PublicKey`), which will be used to build Bob's output.

**To pass this test, make sure you order your outputs correctly! If you're unsure how to do this, make sure to read the `Does the output order matter for the refund transaction?` dropdown above**.

```rust
pub fn build_refund_transaction(
    funding_txin: TxIn,
    alice_pubkey: PublicKey,
    bob_pubkey: PublicKey,
    alice_balance: u64,
    bob_balance: u64
) -> Transaction {

    // Step 1: Build a Output Scripts

    // Step 2: Define Outputs

    // Step 3: Define Version and Locktime

    // Step 4: Build and Return the Transaction
    // -- remember, inputs and outputs must be passed in as vectors (vec![])
}
```

<details>
  <summary>Step 1: Build a Output Scripts</summary>

For our refund transaction, we'll be creating individual P2WPKH outputs. To create a P2WPKH output, you can simply use the provided helper function, `p2wpkh_output_script`.

```rust
let alice_script = p2wpkh_output_script(alice_pubkey);
let bob_script = p2wpkh_output_script(bob_pubkey);
```

Under the hood, `p2wpkh_output_script` simply takes a public key and converts it to a P2WPKH output. You're more than welcome (and encouraged!) to create the P2WPKH script yourself, instead of using the helper function.

```rust
pub fn p2wpkh_output_script(public_key: PublicKey) -> ScriptBuf {
    ScriptBuf::new_p2wpkh(&public_key.wpubkey_hash().unwrap())
}
```

In case you're curious what's happening above, we're using taking the public key and calling the `.wpubkey_hash()` method to get its 160-bit hash, which is passed into the witness program. Technically, the method will return a `Result` [type](https://doc.rust-lang.org/std/result/) in Rust, so we'll need to call `.unwrap()` to get the hash (or error, if there is one). Once we have the hash, we can pass it into the `new_p2wpkh` method, which will return a P2WPKH output for us. You can read more about that method [here](https://docs.rs/bitcoin/latest/bitcoin/struct.ScriptBuf.html#method.new_p2wpkh.


</details>

<details>
  <summary>Step 2: Define Outputs</summary>

Similar to what we did for the funding transaction, we'll need to create `TxOut` objects for Alice and Bob using the `build_output` function, which takes each balance and the corresponding P2WPKH script.

```rust
let alice_output = build_output(alice_balance, alice_script);

let bob_output = build_output(bob_balance, bob_script);
```
</details>

<details>
  <summary>Step 3: Define Version and Locktime</summary>

Set the transaction version to 2 and locktime to zero using the provided rust-bitcoin enums.

```rust
let version = Version::TWO;
let locktime = LockTime::ZERO;
```
- `Version::TWO` sets the transaction version to 2, which supports BIP-68 relative locktimes.
- `LockTime::ZERO` indicates no timelock on the transaction.

</details>

<details>
  <summary>Step 4: Build and Return the Transaction</summary>

Construct the `Transaction` object using the `build_transaction` helper function, with the defined version, locktime, inputs, and the output in a vector.

```rust
pub fn build_transaction(version: Version, locktime: LockTime, tx_ins: Vec<TxIn>, tx_outs: Vec<TxOut>) -> Transaction {
    Transaction {
        version: version,
        lock_time: locktime,
        input: tx_ins,
        output: tx_outs,
    }
}
```

Remember, `build_transaction` expects `tx_ins` and `tx_outs` to be a **vector** (think: list) of `TxIn` and `TxOut` objects, respectively. To wrap your inputs or output in a vector, you can use the following notation:

```rust
vec![output_a, output_b]
```

</details>

## 👉  Get Our Refund Transaction

Once your `build_refund_transaction` is passing the tests, go to a **Shell** in your Repl and type in the below command. Make sure to replace `<funding_tx_id>` with the TxID from our funding transaction!

```
cargo run -- refund -t <funding_tx_id> 
```

Once the program runs and you get the **Tx Hex** and **Tx ID**, save them in the file `src/exercises/transactions.txt` under the headings **Refund Tx Hex** and **Refund Tx ID**.